"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/uploadCSVFile/uploadCSVfile.jsx":
/*!****************************************************!*\
  !*** ./components/uploadCSVFile/uploadCSVfile.jsx ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _services_csvParser_csvParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/services/csvParser/csvParser */ \"./services/csvParser/csvParser.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! papaparse */ \"./node_modules/papaparse/papaparse.min.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nfunction UploadCSVFile(param) {\n    let { parsedData } = param;\n    const passFileValidations = (file)=>{\n        if (file.type !== \"text/csv\") {\n            console.log(\"Please select a CSV file\");\n            return false;\n        }\n        if (file.size === 0) {\n            console.log(\"File is empty\");\n            return false;\n        }\n        if (file.size > 1024 * 1024) {\n            console.log(\"File size exceeds the limit\");\n            return false;\n        }\n        return true;\n    };\n    const handleFileUpload = (event)=>{\n        const file = event.target.files[0];\n        if (!passFileValidations(file)) {\n            return;\n        }\n        papaparse__WEBPACK_IMPORTED_MODULE_2___default().parse(file, {\n            complete: (result)=>{\n                let csvData = result.data;\n                csvData = csvData.map((record)=>{\n                    if (record.DateTo === \"NULL\") {\n                        let currentDate = new Date();\n                        let day = currentDate.getDate();\n                        if (day < 10) {\n                            day = \"0\".concat(day);\n                        }\n                        let month = currentDate.getMonth() + 1;\n                        if (month < 10) {\n                            month = \"0\".concat(month);\n                        }\n                        const year = currentDate.getFullYear();\n                        record.DateTo = \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n                    } else {\n                        const match = record.DateTo.match(/^(\\d{1,2})[./-](\\d{1,2})[./-](\\d{4})$/);\n                        if (match) {\n                            let [, day, month, year] = match;\n                            if (day < 10 && !day.includes(\"0\")) {\n                                day = \"0\".concat(day);\n                            }\n                            if (month < 10 && !month.includes(\"0\")) {\n                                month = \"0\".concat(month);\n                            }\n                            record.DateTo = \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n                        }\n                    }\n                    const match = record.DateFrom.match(/^(\\d{1,2})[./-](\\d{1,2})[./-](\\d{4})$/);\n                    if (match) {\n                        let [, day, month, year] = match;\n                        if (day < 10 && !day.includes(\"0\")) {\n                            day = \"0\".concat(day);\n                        }\n                        if (month < 10 && !month.includes(\"0\")) {\n                            month = \"0\".concat(month);\n                        }\n                        record.DateFrom = \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n                    }\n                    return record;\n                });\n                let projects = Object.groupBy(csvData, (param)=>{\n                    let { ProjectID } = param;\n                    return ProjectID;\n                });\n                const identifiers = [];\n                let finalResult = {};\n                console.log(\"projects\", projects);\n                Object.keys(projects).forEach((project)=>{\n                    for(let i = 0; i < projects[project].length; i++){\n                        for(let j = i + 1; j < projects[project].length; j++){\n                            const firstEmployee = projects[project][i];\n                            const secondEmployee = projects[project][j];\n                            let pairIndentifier;\n                            // console.log(firstEmployee);\n                            // console.log(secondEmployee);\n                            if (firstEmployee.EmpID !== secondEmployee.EmpID) {\n                                pairIndentifier = buildEmployeePairIdentifier(firstEmployee.EmpID, secondEmployee.EmpID);\n                            }\n                            const overlapDaysCount = calculateOverlapDays(new Date(firstEmployee.DateFrom), new Date(firstEmployee.DateTo), new Date(secondEmployee.DateFrom), new Date(secondEmployee.DateTo));\n                            if (overlapDaysCount && pairIndentifier) {\n                                if (finalResult.hasOwnProperty(pairIndentifier)) {\n                                    finalResult[pairIndentifier] += overlapDaysCount;\n                                } else {\n                                    finalResult[pairIndentifier] = overlapDaysCount;\n                                }\n                            }\n                        // console.log(\"pairIndentifier\", pairIndentifier);\n                        // if (!identifiers.includes(identifier) && firstEmployee.EmpID !== secondEmployee.EmpID) {\n                        //     identifiers.push(identifier);\n                        // }\n                        }\n                    }\n                });\n                console.log(\"result\", finalResult);\n                function buildEmployeePairIdentifier(firstEmployee, secondEmployee) {\n                    return \"\".concat(firstEmployee, \"-\").concat(secondEmployee);\n                }\n                function calculateOverlapDays(firstEmployeeStartDate, firstEmployeeEndDate, secondEmployeeStartDate, secondEmployeeEndDate) {\n                    // Calculate the overlap period\n                    const overlapStartDate = new Date(Math.max(firstEmployeeStartDate, secondEmployeeStartDate));\n                    const overlapEndDate = new Date(Math.min(firstEmployeeEndDate, secondEmployeeEndDate));\n                    // If there's no overlap, return 0\n                    if (overlapStartDate > overlapEndDate) {\n                        return 0;\n                    }\n                    // Calculate the number of days in the overlap period\n                    const millisecondsInDay = 1000 * 60 * 60 * 24;\n                    const overlapDays = Math.floor((overlapEndDate - overlapStartDate) / millisecondsInDay) + 1;\n                    return overlapDays;\n                }\n                console.log(\"identifiers\", identifiers);\n            // const groupedData = {};\n            // csvData.forEach(entry => {\n            //     const key = entry.EmpID + '-' + entry.ProjectID;\n            //     if (!groupedData[key]) {\n            //         groupedData[key] = [];\n            //     }\n            //     groupedData[key].push(entry);\n            // });\n            // console.log(\"groupedData\", groupedData);\n            // {\n            //     {\n            //         1-2: 2,\n            //     }\n            // }\n            // for (const key in groupedData) {\n            //     if (groupedData[key].length > 1) {\n            //         const employees = groupedData[key].map(entry => entry.EmpID);\n            //         console.log(\"employees\", employees);\n            //         let daysWorked = 0;\n            //         groupedData[key].forEach(entry => {\n            //             const fromDate = new Date(entry.DateFrom);\n            //             const toDate = new Date(entry.DateTo);\n            //             daysWorked += (toDate - fromDate) / (1000 * 60 * 60 * 24);\n            //         });\n            //         console.log(\"daysWorked\", daysWorked);\n            //         const pairKey = employees.sort().join('-');\n            //         console.log(\"pairKey\", pairKey);\n            //         employeePairs[pairKey] = (employeePairs[pairKey] || 0) + daysWorked;\n            //         console.log(\"employeePairs\", employeePairs);\n            //     }\n            // }\n            },\n            header: true\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n        type: \"file\",\n        onChange: handleFileUpload\n    }, void 0, false, {\n        fileName: \"/Users/martinashebova/Desktop/marti/-Martina---Shebova--employees/components/uploadCSVFile/uploadCSVfile.jsx\",\n        lineNumber: 210,\n        columnNumber: 12\n    }, this);\n}\n_c = UploadCSVFile;\n/* harmony default export */ __webpack_exports__[\"default\"] = (UploadCSVFile);\nvar _c;\n$RefreshReg$(_c, \"UploadCSVFile\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL3VwbG9hZENTVkZpbGUvdXBsb2FkQ1NWZmlsZS5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF1RDtBQUMxQjtBQUU3QixTQUFTRSxjQUFjLEtBQWM7UUFBZCxFQUFFQyxVQUFVLEVBQUUsR0FBZDtJQUVuQixNQUFNQyxzQkFBc0IsQ0FBQ0M7UUFDekIsSUFBSUEsS0FBS0MsSUFBSSxLQUFLLFlBQVk7WUFDMUJDLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE9BQU87UUFDWDtRQUVBLElBQUlILEtBQUtJLElBQUksS0FBSyxHQUFHO1lBQ2pCRixRQUFRQyxHQUFHLENBQUM7WUFDWixPQUFPO1FBQ1g7UUFFQSxJQUFJSCxLQUFLSSxJQUFJLEdBQUcsT0FBTyxNQUFNO1lBQ3pCRixRQUFRQyxHQUFHLENBQUM7WUFDWixPQUFPO1FBQ1g7UUFFQSxPQUFPO0lBQ1g7SUFFQSxNQUFNRSxtQkFBbUIsQ0FBQ0M7UUFDdEIsTUFBTU4sT0FBT00sTUFBTUMsTUFBTSxDQUFDQyxLQUFLLENBQUMsRUFBRTtRQUVsQyxJQUFJLENBQUNULG9CQUFvQkMsT0FBTztZQUM1QjtRQUNKO1FBRUFKLHNEQUFVLENBQUNJLE1BQU07WUFDYlUsVUFBVSxDQUFDQztnQkFDUCxJQUFJQyxVQUFVRCxPQUFPRSxJQUFJO2dCQUN6QkQsVUFBVUEsUUFBUUUsR0FBRyxDQUFDQyxDQUFBQTtvQkFDbEIsSUFBSUEsT0FBT0MsTUFBTSxLQUFLLFFBQVE7d0JBQzFCLElBQUlDLGNBQWMsSUFBSUM7d0JBQ3RCLElBQUlDLE1BQU1GLFlBQVlHLE9BQU87d0JBRTdCLElBQUlELE1BQU0sSUFBSTs0QkFDVkEsTUFBTSxJQUFRLE9BQUpBO3dCQUNkO3dCQUVBLElBQUlFLFFBQVFKLFlBQVlLLFFBQVEsS0FBSzt3QkFFckMsSUFBSUQsUUFBUSxJQUFJOzRCQUNaQSxRQUFRLElBQVUsT0FBTkE7d0JBQ2hCO3dCQUVBLE1BQU1FLE9BQU9OLFlBQVlPLFdBQVc7d0JBRXBDVCxPQUFPQyxNQUFNLEdB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RCxVQUFVekQ7Ozs7OztBQUN4QztLQS9NU1I7QUFpTlQsK0RBQWVBLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy91cGxvYWRDU1ZGaWxlL3VwbG9hZENTVmZpbGUuanN4P2RjYWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNzdlBhcnNlciBmcm9tICdAL3NlcnZpY2VzL2NzdlBhcnNlci9jc3ZQYXJzZXInO1xuaW1wb3J0IFBhcGEgZnJvbSAncGFwYXBhcnNlJztcblxuZnVuY3Rpb24gVXBsb2FkQ1NWRmlsZSh7IHBhcnNlZERhdGEgfSkge1xuXG4gICAgY29uc3QgcGFzc0ZpbGVWYWxpZGF0aW9ucyA9IChmaWxlKSA9PiB7XG4gICAgICAgIGlmIChmaWxlLnR5cGUgIT09ICd0ZXh0L2NzdicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQbGVhc2Ugc2VsZWN0IGEgQ1NWIGZpbGUnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGaWxlIGlzIGVtcHR5Jyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsZS5zaXplID4gMTAyNCAqIDEwMjQpIHsgLy8gMSBNQiBsaW1pdFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZpbGUgc2l6ZSBleGNlZWRzIHRoZSBsaW1pdCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlRmlsZVVwbG9hZCA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlID0gZXZlbnQudGFyZ2V0LmZpbGVzWzBdO1xuXG4gICAgICAgIGlmICghcGFzc0ZpbGVWYWxpZGF0aW9ucyhmaWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgUGFwYS5wYXJzZShmaWxlLCB7XG4gICAgICAgICAgICBjb21wbGV0ZTogKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjc3ZEYXRhID0gcmVzdWx0LmRhdGE7XG4gICAgICAgICAgICAgICAgY3N2RGF0YSA9IGNzdkRhdGEubWFwKHJlY29yZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuRGF0ZVRvID09PSBcIk5VTExcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXkgPSBjdXJyZW50RGF0ZS5nZXREYXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXkgPCAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheSA9IGAwJHtkYXl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1vbnRoID0gY3VycmVudERhdGUuZ2V0TW9udGgoKSArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb250aCA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSBgMCR7bW9udGh9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeWVhciA9IGN1cnJlbnREYXRlLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZC5EYXRlVG8gPSBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1gO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJlY29yZC5EYXRlVG8ubWF0Y2goL14oXFxkezEsMn0pWy4vLV0oXFxkezEsMn0pWy4vLV0oXFxkezR9KSQvKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFssIGRheSwgbW9udGgsIHllYXJdID0gbWF0Y2g7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF5IDwgMTAgJiYgIWRheS5pbmNsdWRlcyhcIjBcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5ID0gYDAke2RheX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb250aCA8IDEwICYmICFtb250aC5pbmNsdWRlcyhcIjBcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSBgMCR7bW9udGh9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQuRGF0ZVRvID0gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVjb3JkLkRhdGVGcm9tLm1hdGNoKC9eKFxcZHsxLDJ9KVsuLy1dKFxcZHsxLDJ9KVsuLy1dKFxcZHs0fSkkLyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgWywgZGF5LCBtb250aCwgeWVhcl0gPSBtYXRjaDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRheSA8IDEwICYmICFkYXkuaW5jbHVkZXMoXCIwXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5ID0gYDAke2RheX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9udGggPCAxMCAmJiAhbW9udGguaW5jbHVkZXMoXCIwXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPSBgMCR7bW9udGh9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLkRhdGVGcm9tID0gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmRcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgbGV0IHByb2plY3RzID0gT2JqZWN0Lmdyb3VwQnkoY3N2RGF0YSwgKHsgUHJvamVjdElEIH0pID0+IFByb2plY3RJRCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgZmluYWxSZXN1bHQgPSB7fTtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHJvamVjdHNcIiwgcHJvamVjdHMpO1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocHJvamVjdHMpLmZvckVhY2gocHJvamVjdCA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9qZWN0c1twcm9qZWN0XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgcHJvamVjdHNbcHJvamVjdF0ubGVuZ3RoOyBqKyspIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0RW1wbG95ZWUgPSBwcm9qZWN0c1twcm9qZWN0XVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWNvbmRFbXBsb3llZSA9IHByb2plY3RzW3Byb2plY3RdW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYWlySW5kZW50aWZpZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhmaXJzdEVtcGxveWVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhzZWNvbmRFbXBsb3llZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RFbXBsb3llZS5FbXBJRCAhPT0gc2Vjb25kRW1wbG95ZWUuRW1wSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFpckluZGVudGlmaWVyID0gYnVpbGRFbXBsb3llZVBhaXJJZGVudGlmaWVyKGZpcnN0RW1wbG95ZWUuRW1wSUQsIHNlY29uZEVtcGxveWVlLkVtcElEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdmVybGFwRGF5c0NvdW50ID0gY2FsY3VsYXRlT3ZlcmxhcERheXMobmV3IERhdGUoZmlyc3RFbXBsb3llZS5EYXRlRnJvbSksIG5ldyBEYXRlKGZpcnN0RW1wbG95ZWUuRGF0ZVRvKSwgbmV3IERhdGUoc2Vjb25kRW1wbG95ZWUuRGF0ZUZyb20pLCBuZXcgRGF0ZShzZWNvbmRFbXBsb3llZS5EYXRlVG8pKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob3ZlcmxhcERheXNDb3VudCAmJiBwYWlySW5kZW50aWZpZXIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmaW5hbFJlc3VsdC5oYXNPd25Qcm9wZXJ0eShwYWlySW5kZW50aWZpZXIpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0W3BhaXJJbmRlbnRpZmllcl0gKz0gb3ZlcmxhcERheXNDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFJlc3VsdFtwYWlySW5kZW50aWZpZXJdID0gb3ZlcmxhcERheXNDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInBhaXJJbmRlbnRpZmllclwiLCBwYWlySW5kZW50aWZpZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKCFpZGVudGlmaWVycy5pbmNsdWRlcyhpZGVudGlmaWVyKSAmJiBmaXJzdEVtcGxveWVlLkVtcElEICE9PSBzZWNvbmRFbXBsb3llZS5FbXBJRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZXN1bHRcIiwgZmluYWxSZXN1bHQpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJ1aWxkRW1wbG95ZWVQYWlySWRlbnRpZmllcihmaXJzdEVtcGxveWVlLCBzZWNvbmRFbXBsb3llZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtmaXJzdEVtcGxveWVlfS0ke3NlY29uZEVtcGxveWVlfWA7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjYWxjdWxhdGVPdmVybGFwRGF5cyhcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFbXBsb3llZVN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFbXBsb3llZUVuZERhdGUsXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZEVtcGxveWVlU3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRFbXBsb3llZUVuZERhdGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBvdmVybGFwIHBlcmlvZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdmVybGFwU3RhcnREYXRlID0gbmV3IERhdGUoTWF0aC5tYXgoZmlyc3RFbXBsb3llZVN0YXJ0RGF0ZSwgc2Vjb25kRW1wbG95ZWVTdGFydERhdGUpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcEVuZERhdGUgPSBuZXcgRGF0ZShNYXRoLm1pbihmaXJzdEVtcGxveWVlRW5kRGF0ZSwgc2Vjb25kRW1wbG95ZWVFbmREYXRlKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBvdmVybGFwLCByZXR1cm4gMFxuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcFN0YXJ0RGF0ZSA+IG92ZXJsYXBFbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhlIG92ZXJsYXAgcGVyaW9kXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kc0luRGF5ID0gMTAwMCAqIDYwICogNjAgKiAyNDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcERheXMgPSBNYXRoLmZsb29yKChvdmVybGFwRW5kRGF0ZSAtIG92ZXJsYXBTdGFydERhdGUpIC8gbWlsbGlzZWNvbmRzSW5EYXkpICsgMTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmxhcERheXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJpZGVudGlmaWVyc1wiLCBpZGVudGlmaWVycyk7XG5cblxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IGdyb3VwZWREYXRhID0ge307XG5cbiAgICAgICAgICAgICAgICAvLyBjc3ZEYXRhLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICAgICAgICAgIC8vICAgICBjb25zdCBrZXkgPSBlbnRyeS5FbXBJRCArICctJyArIGVudHJ5LlByb2plY3RJRDtcblxuICAgICAgICAgICAgICAgIC8vICAgICBpZiAoIWdyb3VwZWREYXRhW2tleV0pIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGdyb3VwZWREYXRhW2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgICBncm91cGVkRGF0YVtrZXldLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZ3JvdXBlZERhdGFcIiwgZ3JvdXBlZERhdGEpO1xuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgICAge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgMS0yOiAyLFxuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgLy8gZm9yIChjb25zdCBrZXkgaW4gZ3JvdXBlZERhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKGdyb3VwZWREYXRhW2tleV0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgY29uc3QgZW1wbG95ZWVzID0gZ3JvdXBlZERhdGFba2V5XS5tYXAoZW50cnkgPT4gZW50cnkuRW1wSUQpO1xuXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBjb25zb2xlLmxvZyhcImVtcGxveWVlc1wiLCBlbXBsb3llZXMpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IGRheXNXb3JrZWQgPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBncm91cGVkRGF0YVtrZXldLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIGNvbnN0IGZyb21EYXRlID0gbmV3IERhdGUoZW50cnkuRGF0ZUZyb20pO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIGNvbnN0IHRvRGF0ZSA9IG5ldyBEYXRlKGVudHJ5LkRhdGVUbyk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgZGF5c1dvcmtlZCArPSAodG9EYXRlIC0gZnJvbURhdGUpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGNvbnNvbGUubG9nKFwiZGF5c1dvcmtlZFwiLCBkYXlzV29ya2VkKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGNvbnN0IHBhaXJLZXkgPSBlbXBsb3llZXMuc29ydCgpLmpvaW4oJy0nKTtcblxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgY29uc29sZS5sb2coXCJwYWlyS2V5XCIsIHBhaXJLZXkpO1xuXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBlbXBsb3llZVBhaXJzW3BhaXJLZXldID0gKGVtcGxveWVlUGFpcnNbcGFpcktleV0gfHwgMCkgKyBkYXlzV29ya2VkO1xuXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBjb25zb2xlLmxvZyhcImVtcGxveWVlUGFpcnNcIiwgZW1wbG95ZWVQYWlycyk7XG5cbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWFkZXI6IHRydWVcbiAgICAgICAgfSlcbiAgICB9XG5cblxuICAgIHJldHVybiA8aW5wdXQgdHlwZT1cImZpbGVcIiBvbkNoYW5nZT17aGFuZGxlRmlsZVVwbG9hZH0gLz5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVXBsb2FkQ1NWRmlsZTsiXSwibmFtZXMiOlsiY3N2UGFyc2VyIiwiUGFwYSIsIlVwbG9hZENTVkZpbGUiLCJwYXJzZWREYXRhIiwicGFzc0ZpbGVWYWxpZGF0aW9ucyIsImZpbGUiLCJ0eXBlIiwiY29uc29sZSIsImxvZyIsInNpemUiLCJoYW5kbGVGaWxlVXBsb2FkIiwiZXZlbnQiLCJ0YXJnZXQiLCJmaWxlcyIsInBhcnNlIiwiY29tcGxldGUiLCJyZXN1bHQiLCJjc3ZEYXRhIiwiZGF0YSIsIm1hcCIsInJlY29yZCIsIkRhdGVUbyIsImN1cnJlbnREYXRlIiwiRGF0ZSIsImRheSIsImdldERhdGUiLCJtb250aCIsImdldE1vbnRoIiwieWVhciIsImdldEZ1bGxZZWFyIiwibWF0Y2giLCJpbmNsdWRlcyIsIkRhdGVGcm9tIiwicHJvamVjdHMiLCJPYmplY3QiLCJncm91cEJ5IiwiUHJvamVjdElEIiwiaWRlbnRpZmllcnMiLCJmaW5hbFJlc3VsdCIsImtleXMiLCJmb3JFYWNoIiwicHJvamVjdCIsImkiLCJsZW5ndGgiLCJqIiwiZmlyc3RFbXBsb3llZSIsInNlY29uZEVtcGxveWVlIiwicGFpckluZGVudGlmaWVyIiwiRW1wSUQiLCJidWlsZEVtcGxveWVlUGFpcklkZW50aWZpZXIiLCJvdmVybGFwRGF5c0NvdW50IiwiY2FsY3VsYXRlT3ZlcmxhcERheXMiLCJoYXNPd25Qcm9wZXJ0eSIsImZpcnN0RW1wbG95ZWVTdGFydERhdGUiLCJmaXJzdEVtcGxveWVlRW5kRGF0ZSIsInNlY29uZEVtcGxveWVlU3RhcnREYXRlIiwic2Vjb25kRW1wbG95ZWVFbmREYXRlIiwib3ZlcmxhcFN0YXJ0RGF0ZSIsIk1hdGgiLCJtYXgiLCJvdmVybGFwRW5kRGF0ZSIsIm1pbiIsIm1pbGxpc2Vjb25kc0luRGF5Iiwib3ZlcmxhcERheXMiLCJmbG9vciIsImhlYWRlciIsImlucHV0Iiwib25DaGFuZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/uploadCSVFile/uploadCSVfile.jsx\n"));

/***/ })

});