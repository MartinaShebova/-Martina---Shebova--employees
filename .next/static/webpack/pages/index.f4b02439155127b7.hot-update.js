"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/uploadCSVFile/uploadCSVfile.jsx":
/*!****************************************************!*\
  !*** ./components/uploadCSVFile/uploadCSVfile.jsx ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _services_csvParser_csvParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/services/csvParser/csvParser */ \"./services/csvParser/csvParser.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! papaparse */ \"./node_modules/papaparse/papaparse.min.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nfunction UploadCSVFile(param) {\n    let { parsedData } = param;\n    const passFileValidations = (file)=>{\n        if (file.type !== \"text/csv\") {\n            console.log(\"Please select a CSV file\");\n            return false;\n        }\n        if (file.size === 0) {\n            console.log(\"File is empty\");\n            return false;\n        }\n        if (file.size > 1024 * 1024) {\n            console.log(\"File size exceeds the limit\");\n            return false;\n        }\n        return true;\n    };\n    const handleFileUpload = (event)=>{\n        const file = event.target.files[0];\n        if (!passFileValidations(file)) {\n            return;\n        }\n        papaparse__WEBPACK_IMPORTED_MODULE_2___default().parse(file, {\n            complete: (result)=>{\n                let csvData = result.data;\n                csvData = csvData.map((record)=>{\n                    if (record.DateTo === \"NULL\") {\n                        let currentDate = new Date();\n                        let day = currentDate.getDate();\n                        if (day < 10) {\n                            day = \"0\".concat(day);\n                        }\n                        let month = currentDate.getMonth() + 1;\n                        if (month < 10) {\n                            month = \"0\".concat(month);\n                        }\n                        const year = currentDate.getFullYear();\n                        record.DateTo = \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n                    } else {\n                        const match = record.DateTo.match(/^(\\d{1,2})[./-](\\d{1,2})[./-](\\d{4})$/);\n                        if (match) {\n                            let [, day, month, year] = match;\n                            if (day < 10 && !day.includes(\"0\")) {\n                                day = \"0\".concat(day);\n                            }\n                            if (month < 10 && !month.includes(\"0\")) {\n                                month = \"0\".concat(month);\n                            }\n                            record.DateTo = \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n                        }\n                    }\n                    const match = record.DateFrom.match(/^(\\d{1,2})[./-](\\d{1,2})[./-](\\d{4})$/);\n                    if (match) {\n                        let [, day, month, year] = match;\n                        if (day < 10 && !day.includes(\"0\")) {\n                            day = \"0\".concat(day);\n                        }\n                        if (month < 10 && !month.includes(\"0\")) {\n                            month = \"0\".concat(month);\n                        }\n                        record.DateFrom = \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n                    }\n                    return record;\n                });\n                let projects = Object.groupBy(csvData, (param)=>{\n                    let { ProjectID } = param;\n                    return ProjectID;\n                });\n                const identifiers = [];\n                let finalResult = {};\n                console.log(\"projects\", projects);\n                Object.keys(projects).forEach((project)=>{\n                    for(let i = 0; i < projects[project].length; i++){\n                        for(let j = i + 1; j < projects[project].length; j++){\n                            const firstEmployee = projects[project][i];\n                            const secondEmployee = projects[project][j];\n                            let pairIndentifier;\n                            // console.log(firstEmployee);\n                            // console.log(secondEmployee);\n                            if (firstEmployee.EmpID !== secondEmployee.EmpID) {\n                                pairIndentifier = buildEmployeePairIdentifier(firstEmployee.EmpID, secondEmployee.EmpID);\n                            }\n                            const overlapDaysCount = calculateOverlapDays(new Date(firstEmployee.DateFrom), new Date(firstEmployee.DateTo), new Date(secondEmployee.DateFrom), new Date(secondEmployee.DateTo));\n                            if (overlapDaysCount && pairIndentifier) {\n                                if (finalResult.hasOwnProperty(pairIndentifier)) {\n                                    finalResult.pairIndentifier += overlapDaysCount;\n                                } else {\n                                    finalResult.pairIndentifier = overlapDaysCount;\n                                }\n                            }\n                            console.log(\"result\", finalResult);\n                        // console.log(\"pairIndentifier\", pairIndentifier);\n                        // if (!identifiers.includes(identifier) && firstEmployee.EmpID !== secondEmployee.EmpID) {\n                        //     identifiers.push(identifier);\n                        // }\n                        }\n                    }\n                });\n                function buildEmployeePairIdentifier(firstEmployee, secondEmployee) {\n                    return \"\".concat(firstEmployee, \"-\").concat(secondEmployee);\n                }\n                function calculateOverlapDays(firstEmployeeStartDate, firstEmployeeEndDate, secondEmployeeStartDate, secondEmployeeEndDate) {\n                    // Calculate the overlap period\n                    const overlapStartDate = new Date(Math.max(firstEmployeeStartDate, secondEmployeeStartDate));\n                    const overlapEndDate = new Date(Math.min(firstEmployeeEndDate, secondEmployeeEndDate));\n                    // If there's no overlap, return 0\n                    if (overlapStartDate > overlapEndDate) {\n                        return 0;\n                    }\n                    // Calculate the number of days in the overlap period\n                    const millisecondsInDay = 1000 * 60 * 60 * 24;\n                    const overlapDays = Math.floor((overlapEndDate - overlapStartDate) / millisecondsInDay) + 1;\n                    return overlapDays;\n                }\n                console.log(\"identifiers\", identifiers);\n            // const groupedData = {};\n            // csvData.forEach(entry => {\n            //     const key = entry.EmpID + '-' + entry.ProjectID;\n            //     if (!groupedData[key]) {\n            //         groupedData[key] = [];\n            //     }\n            //     groupedData[key].push(entry);\n            // });\n            // console.log(\"groupedData\", groupedData);\n            // {\n            //     {\n            //         1-2: 2,\n            //     }\n            // }\n            // for (const key in groupedData) {\n            //     if (groupedData[key].length > 1) {\n            //         const employees = groupedData[key].map(entry => entry.EmpID);\n            //         console.log(\"employees\", employees);\n            //         let daysWorked = 0;\n            //         groupedData[key].forEach(entry => {\n            //             const fromDate = new Date(entry.DateFrom);\n            //             const toDate = new Date(entry.DateTo);\n            //             daysWorked += (toDate - fromDate) / (1000 * 60 * 60 * 24);\n            //         });\n            //         console.log(\"daysWorked\", daysWorked);\n            //         const pairKey = employees.sort().join('-');\n            //         console.log(\"pairKey\", pairKey);\n            //         employeePairs[pairKey] = (employeePairs[pairKey] || 0) + daysWorked;\n            //         console.log(\"employeePairs\", employeePairs);\n            //     }\n            // }\n            },\n            header: true\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n        type: \"file\",\n        onChange: handleFileUpload\n    }, void 0, false, {\n        fileName: \"/Users/martinashebova/Desktop/marti/-Martina---Shebova--employees/components/uploadCSVFile/uploadCSVfile.jsx\",\n        lineNumber: 210,\n        columnNumber: 12\n    }, this);\n}\n_c = UploadCSVFile;\n/* harmony default export */ __webpack_exports__[\"default\"] = (UploadCSVFile);\nvar _c;\n$RefreshReg$(_c, \"UploadCSVFile\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL3VwbG9hZENTVkZpbGUvdXBsb2FkQ1NWZmlsZS5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF1RDtBQUMxQjtBQUU3QixTQUFTRSxjQUFjLEtBQWM7UUFBZCxFQUFFQyxVQUFVLEVBQUUsR0FBZDtJQUVuQixNQUFNQyxzQkFBc0IsQ0FBQ0M7UUFDekIsSUFBSUEsS0FBS0MsSUFBSSxLQUFLLFlBQVk7WUFDMUJDLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE9BQU87UUFDWDtRQUVBLElBQUlILEtBQUtJLElBQUksS0FBSyxHQUFHO1lBQ2pCRixRQUFRQyxHQUFHLENBQUM7WUFDWixPQUFPO1FBQ1g7UUFFQSxJQUFJSCxLQUFLSSxJQUFJLEdBQUcsT0FBTyxNQUFNO1lBQ3pCRixRQUFRQyxHQUFHLENBQUM7WUFDWixPQUFPO1FBQ1g7UUFFQSxPQUFPO0lBQ1g7SUFFQSxNQUFNRSxtQkFBbUIsQ0FBQ0M7UUFDdEIsTUFBTU4sT0FBT00sTUFBTUMsTUFBTSxDQUFDQyxLQUFLLENBQUMsRUFBRTtRQUVsQyxJQUFJLENBQUNULG9CQUFvQkMsT0FBTztZQUM1QjtRQUNKO1FBRUFKLHNEQUFVLENBQUNJLE1BQU07WUFDYlUsVUFBVSxDQUFDQztnQkFDUCxJQUFJQyxVQUFVRCxPQUFPRSxJQUFJO2dCQUN6QkQsVUFBVUEsUUFBUUUsR0FBRyxDQUFDQyxDQUFBQTtvQkFDbEIsSUFBSUEsT0FBT0MsTUFBTSxLQUFLLFFBQVE7d0JBQzFCLElBQUlDLGNBQWMsSUFBSUM7d0JBQ3RCLElBQUlDLE1BQU1GLFlBQVlHLE9BQU87d0JBRTdCLElBQUlELE1BQU0sSUFBSTs0QkFDVkEsTUFBTSxJQUFRLE9BQUpBO3dCQUNkO3dCQUVBLElBQUlFLFFBQVFKLFlBQVlLLFFBQVEsS0FBSzt3QkFFckMsSUFBSUQsUUFBUSxJQUFJOzRCQUNaQSxRQUFRLElBQVUsT0FBTkE7d0JBQ2hCO3dCQUVBLE1BQU1FLE9BQU9OLFlBQVlPLFdBQVc7d0JBRXBDVCxPQUFPQyxNQUFNLEdBQUcsR0FBV0ssT0FBUkUsTUFBSyxLQUFZSixPQUFURSxPQUFNLEtBQU8sT0FBSkY7b0JBQ3hDLE9BQU87d0JBRUgsTUFBTU0sUUFBUVYsT0FBT0MsTUFBTSxDQUFDUyxLQUFLLENBQUM7d0JBRWxDLElBQUlBLE9BQU87NEJBQ1AsSUFBSSxHQUFHTixLQUFLRSxPQUFPRSxLQUFLLEdBQUdFOzRCQUUzQixJQUFJTixNQUFNLE1BQU0sQ0FBQ0EsSUFBSU8sUUFBUSxDQUFDLE1BQU07Z0NBQ2hDUCxNQUFNLElBQVEsT0FBSkE7NEJBQ2Q7NEJBRUEsSUFBSUUsUUFBUSxNQUFNLENBQUNBLE1BQU1LLFFBQVEsQ0FBQyxNQUFNO2dDQUNwQ0wsUUFBUSxJQUFVLE9BQU5BOzRCQUNoQjs0QkFFQU4sT0FBT0MsTUFBTSxHQUFHLEdBQVdLLE9BQVJFLE1BQUssS0FBWUosT0FBVEUsT0FBTSxLQUFPLE9BQUpGO3dCQUN4QztvQkFDSjtvQkFFQSxNQUFNTSxRQUFRVixPQUFPWSxRQUFRLENBQUNGLEtBQUssQ0FBQztvQkFFcEMsSUFBSUEsT0FBTzt3QkFDUCxJQUFJLEdBQUdOLEtBQUtFLE9BQU9FLEtBQUssR0FBR0U7d0JBRTNCLElBQUlOLE1BQU0sTUFBTSxDQUFDQSxJQUFJTyxRQUFRLENBQUMsTUFBTTs0QkFDaENQLE1BQU0sSUFBUSxPQUFKQTt3QkFDZDt3QkFFQSxJQUFJRSxRQUFRLE1BQU0sQ0FBQ0EsTUFBTUssUUFBUSxDQUFDLE1BQU07NEJBQ3BDTCxRQUFRLElBQVUsT0FBTkE7d0JBQ2hCO3dCQUVBTixPQUFPWSxRQUFRLEdBQUcsR0FBV04sT0FBUkUsTUFBSyxLQUFZSixPQUFURSxPQUFNLEtBQU8sT0FBSkY7b0JBQzFDO29CQUVBLE9BQU9KO2dCQUNYO2dCQUVBLElBQUlhLFdBQVdDLE9BQU9DLE9BQU8sQ0FBQ2xCLFNBQVM7d0JBQUMsRUFBRW1CLFNBQVMsRUFBRTsyQkFBS0E7O2dCQUMxRCxNQUFNQyxjQUFjLEVBQUU7Z0JBQ3RCLElBQUlDLGNBQWMsQ0FBQztnQkFFbkIvQixRQUFRQyxHQUFHLENBQUMsWUFBWXlCO2dCQUV4QkMsT0FBT0ssSUFBSSxDQUFDTixVQUFVTyxPQUFPLENBQUNDLENBQUFBO29CQUUxQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVQsUUFBUSxDQUFDUSxRQUFRLENBQUNFLE1BQU0sRUFBRUQsSUFBSzt3QkFDL0MsSUFBSyxJQUFJRSxJQUFJRixJQUFJLEdBQUdFLElBQUlYLFFBQVEsQ0FBQ1EsUUFBUSxDQUFDRSxNQUFNLEVBQUVDLElBQUs7NEJBRW5ELE1BQU1DLGdCQUFnQlosUUFBUSxDQUFDUSxRQUFRLENBQUNDLEVBQUU7NEJBQzFDLE1BQU1JLGlCQUFpQmIsUUFBUSxDQUFDUSxRQUFRLENBQUNHLEVBQUU7NEJBQzNDLElBQUlHOzRCQUVKLDhCQUE4Qjs0QkFDOUIsK0JBQStCOzRCQUUvQixJQUFJRixjQUFjRyxLQUFLLEtBQUtGLGVBQWVFLEtBQUssRUFBRTtnQ0FDOUNELGtCQUFrQkUsNEJBQTRCSixjQUFjRyxLQUFLLEVBQUVGLGVBQWVFLEtBQUs7NEJBQzNGOzRCQUVBLE1BQU1FLG1CQUFtQkMscUJBQXFCLElBQUk1QixLQUFLc0IsY0FBY2IsUUFBUSxHQUFHLElBQUlULEtBQUtzQixjQUFjeEIsTUFBTSxHQUFHLElBQUlFLEtBQUt1QixlQUFlZCxRQUFRLEdBQUcsSUFBSVQsS0FBS3VCLGVBQWV6QixNQUFNOzRCQUVqTCxJQUFHNkIsb0JBQW9CSCxpQkFBZ0I7Z0NBQ25DLElBQUdULFlBQVljLGNBQWMsQ0FBQ0wsa0JBQWlCO29DQUMzQ1QsWUFBWVMsZUFBZSxJQUFJRztnQ0FDbkMsT0FBSztvQ0FDRFosWUFBWVMsZUFBZSxHQUFHRztnQ0FDbEM7NEJBQ0o7NEJBQ0EzQyxRQUFRQyxHQUFHLENBQUMsVUFBVThCO3dCQUN0QixtREFBbUQ7d0JBRW5ELDJGQUEyRjt3QkFDM0Ysb0NBQW9DO3dCQUNwQyxJQUFJO3dCQUNSO29CQUNKO2dCQUNKO2dCQUVBLFNBQVNXLDRCQUE0QkosYUFBYSxFQUFFQyxjQUFjO29CQUU5RCxPQUFPLEdBQW9CQSxPQUFqQkQsZUFBYyxLQUFrQixPQUFmQztnQkFDL0I7Z0JBR0EsU0FBU0sscUJBQ0xFLHNCQUFzQixFQUN0QkMsb0JBQW9CLEVBQ3BCQyx1QkFBdUIsRUFDdkJDLHFCQUFxQjtvQkFFakIsK0JBQStCO29CQUNuQyxNQUFNQyxtQkFBbUIsSUFBSWxDLEtBQUttQyxLQUFLQyxHQUFHLENBQUNOLHdCQUF3QkU7b0JBQ25FLE1BQU1LLGlCQUFpQixJQUFJckMsS0FBS21DLEtBQUtHLEdBQUcsQ0FBQ1Asc0JBQXNCRTtvQkFFL0Qsa0NBQWtDO29CQUNsQyxJQUFJQyxtQkFBbUJHLGdCQUFnQjt3QkFDbkMsT0FBTztvQkFDWDtvQkFFQSxxREFBcUQ7b0JBQ3JELE1BQU1FLG9CQUFvQixPQUFPLEtBQUssS0FBSztvQkFDM0MsTUFBTUMsY0FBY0wsS0FBS00sS0FBSyxDQUFDLENBQUNKLGlCQUFpQkgsZ0JBQWUsSUFBS0sscUJBQXFCO29CQUUxRixPQUFPQztnQkFDWDtnQkFFQXhELFFBQVFDLEdBQUcsQ0FBQyxlQUFlNkI7WUFHM0IsMEJBQTBCO1lBRTFCLDZCQUE2QjtZQUM3Qix1REFBdUQ7WUFFdkQsK0JBQStCO1lBQy9CLGlDQUFpQztZQUNqQyxRQUFRO1lBQ1Isb0NBQW9DO1lBQ3BDLE1BQU07WUFDTiwyQ0FBMkM7WUFDM0MsSUFBSTtZQUNKLFFBQVE7WUFDUixrQkFBa0I7WUFDbEIsUUFBUTtZQUNSLElBQUk7WUFFSixtQ0FBbUM7WUFDbkMseUNBQXlDO1lBQ3pDLHdFQUF3RTtZQUV4RSwrQ0FBK0M7WUFDL0MsOEJBQThCO1lBRTlCLDhDQUE4QztZQUM5Qyx5REFBeUQ7WUFDekQscURBQXFEO1lBQ3JELHlFQUF5RTtZQUN6RSxjQUFjO1lBRWQsaURBQWlEO1lBQ2pELHNEQUFzRDtZQUV0RCwyQ0FBMkM7WUFFM0MsK0VBQStFO1lBRS9FLHVEQUF1RDtZQUV2RCxRQUFRO1lBQ1IsSUFBSTtZQUNSO1lBQ0E0QixRQUFRO1FBQ1o7SUFDSjtJQUdBLHFCQUFPLDhEQUFDQztRQUFNNUQsTUFBSztRQUFPNkQsVUFBVXpEOzs7Ozs7QUFDeEM7S0EvTVNSO0FBaU5ULCtEQUFlQSxhQUFhQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvdXBsb2FkQ1NWRmlsZS91cGxvYWRDU1ZmaWxlLmpzeD9kY2FhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjc3ZQYXJzZXIgZnJvbSAnQC9zZXJ2aWNlcy9jc3ZQYXJzZXIvY3N2UGFyc2VyJztcbmltcG9ydCBQYXBhIGZyb20gJ3BhcGFwYXJzZSc7XG5cbmZ1bmN0aW9uIFVwbG9hZENTVkZpbGUoeyBwYXJzZWREYXRhIH0pIHtcblxuICAgIGNvbnN0IHBhc3NGaWxlVmFsaWRhdGlvbnMgPSAoZmlsZSkgPT4ge1xuICAgICAgICBpZiAoZmlsZS50eXBlICE9PSAndGV4dC9jc3YnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUGxlYXNlIHNlbGVjdCBhIENTViBmaWxlJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmlsZSBpcyBlbXB0eScpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbGUuc2l6ZSA+IDEwMjQgKiAxMDI0KSB7IC8vIDEgTUIgbGltaXRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGaWxlIHNpemUgZXhjZWVkcyB0aGUgbGltaXQnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZUZpbGVVcGxvYWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IGV2ZW50LnRhcmdldC5maWxlc1swXTtcblxuICAgICAgICBpZiAoIXBhc3NGaWxlVmFsaWRhdGlvbnMoZmlsZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIFBhcGEucGFyc2UoZmlsZSwge1xuICAgICAgICAgICAgY29tcGxldGU6IChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY3N2RGF0YSA9IHJlc3VsdC5kYXRhO1xuICAgICAgICAgICAgICAgIGNzdkRhdGEgPSBjc3ZEYXRhLm1hcChyZWNvcmQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLkRhdGVUbyA9PT0gXCJOVUxMXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF5ID0gY3VycmVudERhdGUuZ2V0RGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF5IDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXkgPSBgMCR7ZGF5fWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtb250aCA9IGN1cnJlbnREYXRlLmdldE1vbnRoKCkgKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9udGggPCAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gYDAke21vbnRofWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHllYXIgPSBjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQuRGF0ZVRvID0gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9YDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSByZWNvcmQuRGF0ZVRvLm1hdGNoKC9eKFxcZHsxLDJ9KVsuLy1dKFxcZHsxLDJ9KVsuLy1dKFxcZHs0fSkkLyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBbLCBkYXksIG1vbnRoLCB5ZWFyXSA9IG1hdGNoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRheSA8IDEwICYmICFkYXkuaW5jbHVkZXMoXCIwXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheSA9IGAwJHtkYXl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9udGggPCAxMCAmJiAhbW9udGguaW5jbHVkZXMoXCIwXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gYDAke21vbnRofWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLkRhdGVUbyA9IGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJlY29yZC5EYXRlRnJvbS5tYXRjaCgvXihcXGR7MSwyfSlbLi8tXShcXGR7MSwyfSlbLi8tXShcXGR7NH0pJC8pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFssIGRheSwgbW9udGgsIHllYXJdID0gbWF0Y2g7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXkgPCAxMCAmJiAhZGF5LmluY2x1ZGVzKFwiMFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheSA9IGAwJHtkYXl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vbnRoIDwgMTAgJiYgIW1vbnRoLmluY2x1ZGVzKFwiMFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gYDAke21vbnRofWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZC5EYXRlRnJvbSA9IGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fWA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIGxldCBwcm9qZWN0cyA9IE9iamVjdC5ncm91cEJ5KGNzdkRhdGEsICh7IFByb2plY3RJRCB9KSA9PiBQcm9qZWN0SUQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXJzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGZpbmFsUmVzdWx0ID0ge307XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInByb2plY3RzXCIsIHByb2plY3RzKTtcblxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb2plY3RzKS5mb3JFYWNoKHByb2plY3QgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvamVjdHNbcHJvamVjdF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHByb2plY3RzW3Byb2plY3RdLmxlbmd0aDsgaisrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEVtcGxveWVlID0gcHJvamVjdHNbcHJvamVjdF1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vjb25kRW1wbG95ZWUgPSBwcm9qZWN0c1twcm9qZWN0XVtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFpckluZGVudGlmaWVyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZmlyc3RFbXBsb3llZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coc2Vjb25kRW1wbG95ZWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0RW1wbG95ZWUuRW1wSUQgIT09IHNlY29uZEVtcGxveWVlLkVtcElEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJJbmRlbnRpZmllciA9IGJ1aWxkRW1wbG95ZWVQYWlySWRlbnRpZmllcihmaXJzdEVtcGxveWVlLkVtcElELCBzZWNvbmRFbXBsb3llZS5FbXBJRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcERheXNDb3VudCA9IGNhbGN1bGF0ZU92ZXJsYXBEYXlzKG5ldyBEYXRlKGZpcnN0RW1wbG95ZWUuRGF0ZUZyb20pLCBuZXcgRGF0ZShmaXJzdEVtcGxveWVlLkRhdGVUbyksIG5ldyBEYXRlKHNlY29uZEVtcGxveWVlLkRhdGVGcm9tKSwgbmV3IERhdGUoc2Vjb25kRW1wbG95ZWUuRGF0ZVRvKSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG92ZXJsYXBEYXlzQ291bnQgJiYgcGFpckluZGVudGlmaWVyKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmluYWxSZXN1bHQuaGFzT3duUHJvcGVydHkocGFpckluZGVudGlmaWVyKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFJlc3VsdC5wYWlySW5kZW50aWZpZXIgKz0gb3ZlcmxhcERheXNDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFJlc3VsdC5wYWlySW5kZW50aWZpZXIgPSBvdmVybGFwRGF5c0NvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVzdWx0XCIsIGZpbmFsUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInBhaXJJbmRlbnRpZmllclwiLCBwYWlySW5kZW50aWZpZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKCFpZGVudGlmaWVycy5pbmNsdWRlcyhpZGVudGlmaWVyKSAmJiBmaXJzdEVtcGxveWVlLkVtcElEICE9PSBzZWNvbmRFbXBsb3llZS5FbXBJRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBidWlsZEVtcGxveWVlUGFpcklkZW50aWZpZXIoZmlyc3RFbXBsb3llZSwgc2Vjb25kRW1wbG95ZWUpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7Zmlyc3RFbXBsb3llZX0tJHtzZWNvbmRFbXBsb3llZX1gO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2FsY3VsYXRlT3ZlcmxhcERheXMoXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RW1wbG95ZWVTdGFydERhdGUsXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RW1wbG95ZWVFbmREYXRlLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRFbXBsb3llZVN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kRW1wbG95ZWVFbmREYXRlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgb3ZlcmxhcCBwZXJpb2RcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcFN0YXJ0RGF0ZSA9IG5ldyBEYXRlKE1hdGgubWF4KGZpcnN0RW1wbG95ZWVTdGFydERhdGUsIHNlY29uZEVtcGxveWVlU3RhcnREYXRlKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXBFbmREYXRlID0gbmV3IERhdGUoTWF0aC5taW4oZmlyc3RFbXBsb3llZUVuZERhdGUsIHNlY29uZEVtcGxveWVlRW5kRGF0ZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gb3ZlcmxhcCwgcmV0dXJuIDBcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBTdGFydERhdGUgPiBvdmVybGFwRW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoZSBvdmVybGFwIHBlcmlvZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaWxsaXNlY29uZHNJbkRheSA9IDEwMDAgKiA2MCAqIDYwICogMjQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXBEYXlzID0gTWF0aC5mbG9vcigob3ZlcmxhcEVuZERhdGUgLSBvdmVybGFwU3RhcnREYXRlKSAvIG1pbGxpc2Vjb25kc0luRGF5KSArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJsYXBEYXlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaWRlbnRpZmllcnNcIiwgaWRlbnRpZmllcnMpO1xuXG5cbiAgICAgICAgICAgICAgICAvLyBjb25zdCBncm91cGVkRGF0YSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gY3N2RGF0YS5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgY29uc3Qga2V5ID0gZW50cnkuRW1wSUQgKyAnLScgKyBlbnRyeS5Qcm9qZWN0SUQ7XG5cbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKCFncm91cGVkRGF0YVtrZXldKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBncm91cGVkRGF0YVtrZXldID0gW107XG4gICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgICAgZ3JvdXBlZERhdGFba2V5XS5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImdyb3VwZWREYXRhXCIsIGdyb3VwZWREYXRhKTtcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICAgIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIDEtMjogMixcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICAgIC8vIGZvciAoY29uc3Qga2V5IGluIGdyb3VwZWREYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGlmIChncm91cGVkRGF0YVtrZXldLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGNvbnN0IGVtcGxveWVlcyA9IGdyb3VwZWREYXRhW2tleV0ubWFwKGVudHJ5ID0+IGVudHJ5LkVtcElEKTtcblxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgY29uc29sZS5sb2coXCJlbXBsb3llZXNcIiwgZW1wbG95ZWVzKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBkYXlzV29ya2VkID0gMDtcblxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgZ3JvdXBlZERhdGFba2V5XS5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBjb25zdCBmcm9tRGF0ZSA9IG5ldyBEYXRlKGVudHJ5LkRhdGVGcm9tKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBjb25zdCB0b0RhdGUgPSBuZXcgRGF0ZShlbnRyeS5EYXRlVG8pO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIGRheXNXb3JrZWQgKz0gKHRvRGF0ZSAtIGZyb21EYXRlKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBjb25zb2xlLmxvZyhcImRheXNXb3JrZWRcIiwgZGF5c1dvcmtlZCk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBjb25zdCBwYWlyS2V5ID0gZW1wbG95ZWVzLnNvcnQoKS5qb2luKCctJyk7XG5cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGNvbnNvbGUubG9nKFwicGFpcktleVwiLCBwYWlyS2V5KTtcblxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgZW1wbG95ZWVQYWlyc1twYWlyS2V5XSA9IChlbXBsb3llZVBhaXJzW3BhaXJLZXldIHx8IDApICsgZGF5c1dvcmtlZDtcblxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgY29uc29sZS5sb2coXCJlbXBsb3llZVBhaXJzXCIsIGVtcGxveWVlUGFpcnMpO1xuXG4gICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVhZGVyOiB0cnVlXG4gICAgICAgIH0pXG4gICAgfVxuXG5cbiAgICByZXR1cm4gPGlucHV0IHR5cGU9XCJmaWxlXCIgb25DaGFuZ2U9e2hhbmRsZUZpbGVVcGxvYWR9IC8+XG59XG5cbmV4cG9ydCBkZWZhdWx0IFVwbG9hZENTVkZpbGU7Il0sIm5hbWVzIjpbImNzdlBhcnNlciIsIlBhcGEiLCJVcGxvYWRDU1ZGaWxlIiwicGFyc2VkRGF0YSIsInBhc3NGaWxlVmFsaWRhdGlvbnMiLCJmaWxlIiwidHlwZSIsImNvbnNvbGUiLCJsb2ciLCJzaXplIiwiaGFuZGxlRmlsZVVwbG9hZCIsImV2ZW50IiwidGFyZ2V0IiwiZmlsZXMiLCJwYXJzZSIsImNvbXBsZXRlIiwicmVzdWx0IiwiY3N2RGF0YSIsImRhdGEiLCJtYXAiLCJyZWNvcmQiLCJEYXRlVG8iLCJjdXJyZW50RGF0ZSIsIkRhdGUiLCJkYXkiLCJnZXREYXRlIiwibW9udGgiLCJnZXRNb250aCIsInllYXIiLCJnZXRGdWxsWWVhciIsIm1hdGNoIiwiaW5jbHVkZXMiLCJEYXRlRnJvbSIsInByb2plY3RzIiwiT2JqZWN0IiwiZ3JvdXBCeSIsIlByb2plY3RJRCIsImlkZW50aWZpZXJzIiwiZmluYWxSZXN1bHQiLCJrZXlzIiwiZm9yRWFjaCIsInByb2plY3QiLCJpIiwibGVuZ3RoIiwiaiIsImZpcnN0RW1wbG95ZWUiLCJzZWNvbmRFbXBsb3llZSIsInBhaXJJbmRlbnRpZmllciIsIkVtcElEIiwiYnVpbGRFbXBsb3llZVBhaXJJZGVudGlmaWVyIiwib3ZlcmxhcERheXNDb3VudCIsImNhbGN1bGF0ZU92ZXJsYXBEYXlzIiwiaGFzT3duUHJvcGVydHkiLCJmaXJzdEVtcGxveWVlU3RhcnREYXRlIiwiZmlyc3RFbXBsb3llZUVuZERhdGUiLCJzZWNvbmRFbXBsb3llZVN0YXJ0RGF0ZSIsInNlY29uZEVtcGxveWVlRW5kRGF0ZSIsIm92ZXJsYXBTdGFydERhdGUiLCJNYXRoIiwibWF4Iiwib3ZlcmxhcEVuZERhdGUiLCJtaW4iLCJtaWxsaXNlY29uZHNJbkRheSIsIm92ZXJsYXBEYXlzIiwiZmxvb3IiLCJoZWFkZXIiLCJpbnB1dCIsIm9uQ2hhbmdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/uploadCSVFile/uploadCSVfile.jsx\n"));

/***/ })

});